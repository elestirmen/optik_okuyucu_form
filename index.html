<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Optik Form Tasarla & Oku - Pro</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0a0e1a;
      --bg-secondary: #111827;
      --panel: rgba(17, 24, 39, 0.8);
      --border: rgba(75, 85, 99, 0.4);
      --ink: #f3f4f6;
      --muted: #9ca3af;
      --accent: #06b6d4;
      --accent-glow: rgba(6, 182, 212, 0.3);
      --success: #10b981;
      --warn: #f59e0b;
      --error: #ef4444;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: 'Inter', system-ui, sans-serif;
      background: radial-gradient(ellipse at 20% 0%, rgba(6, 182, 212, 0.15), transparent 50%),
                  radial-gradient(ellipse at 80% 100%, rgba(139, 92, 246, 0.1), transparent 50%),
                  var(--bg);
      color: var(--ink);
      min-height: 100vh;
    }
    h1, h2, h3 { margin: 0; font-weight: 600; }
    .app { max-width: 1400px; margin: 0 auto; padding: 20px 16px 48px; }
    
    header { 
      display: flex; flex-wrap: wrap; gap: 12px; align-items: center; 
      margin-bottom: 20px; padding-bottom: 16px; border-bottom: 1px solid var(--border);
    }
    header h1 { 
      flex: 1 1 auto; font-size: 1.5rem;
      background: linear-gradient(135deg, var(--accent), #8b5cf6);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
    }
    
    .badge { 
      padding: 6px 12px; border-radius: 20px; background: var(--panel); 
      border: 1px solid var(--border); color: var(--muted); font-size: 11px;
      font-family: 'JetBrains Mono', monospace; transition: all 0.3s;
    }
    .badge.ready { background: rgba(16, 185, 129, 0.15); border-color: rgba(16, 185, 129, 0.4); color: #34d399; }
    
    .tabs { display: inline-flex; border: 1px solid var(--border); border-radius: 10px; overflow: hidden; background: var(--panel); }
    .tabs button { border: none; background: transparent; color: var(--muted); padding: 10px 16px; cursor: pointer; font-weight: 500; font-size: 13px; transition: all 0.2s; }
    .tabs button:hover { background: rgba(255,255,255,0.05); }
    .tabs button.active { background: var(--accent); color: #000; font-weight: 600; }
    
    .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(340px, 1fr)); gap: 20px; }
    
    .card { background: var(--panel); border: 1px solid var(--border); border-radius: 16px; padding: 16px; backdrop-filter: blur(20px); }
    .card h3 { margin: 0 0 4px 0; font-size: 15px; display: flex; align-items: center; gap: 8px; }
    .card .hint { font-size: 11px; color: var(--muted); margin-bottom: 10px; }
    
    label { display: block; margin: 8px 0 3px; color: var(--ink); font-weight: 500; font-size: 12px; }
    input, select { 
      width: 100%; padding: 8px 10px; border-radius: 6px; border: 1px solid var(--border); 
      background: var(--bg-secondary); color: var(--ink); font-size: 13px; transition: all 0.2s;
    }
    input:focus, select:focus { outline: none; border-color: var(--accent); box-shadow: 0 0 0 2px var(--accent-glow); }
    
    .btn { 
      background: linear-gradient(135deg, var(--accent), #0891b2); color: #000; border: none; 
      padding: 10px 16px; border-radius: 8px; font-weight: 600; font-size: 13px; cursor: pointer; 
      transition: all 0.2s; display: inline-flex; align-items: center; gap: 6px;
    }
    .btn:hover { transform: translateY(-1px); box-shadow: 0 6px 16px var(--accent-glow); }
    .btn:active { transform: translateY(0); }
    .btn.secondary { background: var(--bg-secondary); color: var(--ink); border: 1px solid var(--border); }
    .btn.secondary:hover { background: rgba(255,255,255,0.1); box-shadow: none; }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none !important; }
    .btn-group { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; margin-top: 12px; }
    
    .view { display: none; } .view.active { display: block; }
    
    /* ===== FORM PREVIEW ===== */
    .form-preview-wrap { 
      background: #fff; border-radius: 10px; padding: 12px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-height: 70vh; overflow: auto;
    }
    
    #formCanvas {
      display: block;
      max-width: 100%;
      height: auto;
      border: 1px solid #ccc;
    }
    
    /* ===== CAMERA & READER ===== */
    .video-wrap { position: relative; background: #000; border: 1px solid var(--border); border-radius: 12px; overflow: hidden; }
    video { width: 100%; display: block; max-height: 320px; object-fit: cover; }
    .overlay { 
      position: absolute; inset: 12px; border: 2px dashed rgba(6, 182, 212, 0.6); border-radius: 8px;
      pointer-events: none; box-shadow: 0 0 0 999px rgba(0,0,0,0.4);
    }
    
    .scan-status {
      position: absolute; bottom: 12px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.8); padding: 6px 14px; border-radius: 16px;
      font-size: 11px; font-family: 'JetBrains Mono', monospace;
      display: flex; align-items: center; gap: 6px;
    }
    .scan-status .dot { width: 6px; height: 6px; border-radius: 50%; background: var(--warn); animation: pulse 1.5s infinite; }
    .scan-status.ready .dot { background: var(--success); animation: none; }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }
    
    .canvas-row { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-top: 12px; }
    .canvas-item { background: var(--bg-secondary); border-radius: 6px; padding: 6px; border: 1px solid var(--border); }
    .canvas-item .label { font-size: 9px; color: var(--muted); margin-bottom: 4px; font-family: 'JetBrains Mono', monospace; }
    canvas.process-canvas { width: 100%; height: auto; border-radius: 4px; background: #000; }
    
    .result-box { 
      background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(6, 182, 212, 0.1));
      border: 1px solid rgba(16, 185, 129, 0.3); padding: 14px; border-radius: 10px; margin-top: 12px;
    }
    .result-box .summary { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px solid var(--border); }
    .result-box .stat { text-align: center; padding: 6px; background: var(--bg-secondary); border-radius: 6px; }
    .result-box .stat-value { font-size: 20px; font-weight: 700; font-family: 'JetBrains Mono', monospace; }
    .result-box .stat-label { font-size: 9px; color: var(--muted); text-transform: uppercase; }
    .result-box .stat.correct .stat-value { color: var(--success); }
    .result-box .stat.wrong .stat-value { color: var(--error); }
    .result-box .stat.net .stat-value { color: var(--accent); }
    
    .result-details { max-height: 180px; overflow-y: auto; font-family: 'JetBrains Mono', monospace; font-size: 10px; background: var(--bg-secondary); padding: 10px; border-radius: 6px; }
    .log { margin-top: 10px; padding: 8px 12px; background: var(--bg-secondary); border-radius: 6px; font-size: 11px; font-family: 'JetBrains Mono', monospace; color: var(--muted); border-left: 3px solid var(--accent); }
    .log.error { border-left-color: var(--error); color: #fca5a5; }
    .log.success { border-left-color: var(--success); color: #6ee7b7; }
    
    .settings-row { display: flex; gap: 12px; flex-wrap: wrap; margin-top: 10px; padding: 10px; background: var(--bg-secondary); border-radius: 6px; }
    .settings-row label { margin: 0; display: flex; align-items: center; gap: 6px; font-size: 11px; }
    .settings-row input { width: 60px; padding: 5px 6px; font-size: 11px; }
    
    .param-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 8px; }
    
    /* Answer Key Section */
    .answer-key-section {
      margin-top: 12px;
      padding: 12px;
      background: var(--bg-secondary);
      border-radius: 8px;
      border: 1px solid var(--border);
    }
    .answer-key-section h4 {
      margin: 0 0 8px 0;
      font-size: 13px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .answer-key-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
      gap: 4px;
      max-height: 200px;
      overflow-y: auto;
      padding: 4px;
    }
    .answer-key-item {
      display: flex;
      align-items: center;
      gap: 2px;
      font-size: 11px;
    }
    .answer-key-item span {
      width: 20px;
      text-align: right;
      font-weight: 600;
      color: var(--muted);
    }
    .answer-key-item select {
      width: 40px;
      padding: 3px;
      font-size: 10px;
    }
    .answer-key-status {
      margin-top: 8px;
      padding: 8px;
      border-radius: 6px;
      font-size: 11px;
      background: rgba(16, 185, 129, 0.1);
      border: 1px solid rgba(16, 185, 129, 0.3);
      color: #6ee7b7;
    }
    .answer-key-status.empty {
      background: rgba(245, 158, 11, 0.1);
      border-color: rgba(245, 158, 11, 0.3);
      color: #fcd34d;
    }
    
    @media print {
      * { visibility: hidden !important; }
      #formCanvas { visibility: visible !important; position: fixed !important; top: 0 !important; left: 0 !important; width: 100% !important; height: auto !important; }
      @page { size: A4; margin: 5mm; }
    }
  </style>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  
  <script>
    window.cvReady = false;
    function onOpenCvReady() {
      window.cvReady = true;
      const badge = document.getElementById('cv-status');
      if (badge) { badge.textContent = '‚úì OpenCV'; badge.classList.add('ready'); }
    }
  </script>
  <script async src="https://docs.opencv.org/4.x/opencv.js" onload="cv['onRuntimeInitialized']=onOpenCvReady;"></script>
</head>
<body>
  <div class="app">
    <header class="no-print">
      <h1>‚ö° Optik Form Pro</h1>
      <span class="badge" id="cv-status">OpenCV...</span>
      <div class="tabs">
        <button class="active" data-view="designer">üìù Tasarla</button>
        <button data-view="reader">üì∑ Oku</button>
      </div>
    </header>

    <main>
      <!-- ===== DESIGNER ===== -->
      <section id="designer" class="view active">
        <div class="grid">
          <div class="card">
            <h3>‚öôÔ∏è Form Ayarlarƒ±</h3>
            <div class="hint">Kompakt optik form tasarƒ±mƒ± - t√ºm boyutlar ayarlanabilir</div>
            
            <div class="param-grid">
              <div><label>Soru Sayƒ±sƒ±</label><input type="number" id="questionCount" min="1" max="200" value="30"></div>
              <div><label>≈ûƒ±k Sayƒ±sƒ±</label>
                <select id="choiceCount">
                  <option value="4">4 (A-D)</option>
                  <option value="5" selected>5 (A-E)</option>
                </select>
              </div>
              <div><label>Soru S√ºtunu</label>
                <select id="columnCount">
                  <option value="1">1</option>
                  <option value="2" selected>2</option>
                  <option value="3">3</option>
                  <option value="4">4</option>
                </select>
              </div>
              <div><label>√ñƒür. No Hane</label><input type="number" id="studentDigits" min="4" max="15" value="10"></div>
              <div><label>Cevap Anahtarƒ±</label>
                <select id="showAnswerKey">
                  <option value="yes" selected>G√∂ster</option>
                  <option value="no">Gizle</option>
                </select>
              </div>
              <div><label>Anahtar ≈ûƒ±k</label><input type="number" id="answerKeyChoices" min="4" max="10" value="10"></div>
            </div>
            
            <div class="param-grid" style="margin-top:8px;">
              <div><label>Form Geni≈ülik (px)</label><input type="number" id="formWidth" min="300" max="1200" value="350" step="50"></div>
              <div><label>Form Y√ºkseklik (px)</label><input type="number" id="formHeight" min="400" max="2000" value="550" step="50"></div>
              <div><label>Baloncuk Boyutu</label><input type="number" id="bubbleSize" min="8" max="24" value="14" step="1"></div>
              <div><label>Satƒ±r Aralƒ±ƒüƒ±</label><input type="number" id="rowGap" min="1" max="20" value="4" step="1"></div>
              <div><label>Kalite √áarpanƒ±</label>
                <select id="qualityScale">
                  <option value="1">1x (Hƒ±zlƒ±)</option>
                  <option value="2" selected>2x (Normal)</option>
                  <option value="3">3x (Y√ºksek)</option>
                  <option value="4">4x (√áok Y√ºksek)</option>
                </select>
              </div>
              <div><label>Harf Tekrar (soru)</label><input type="number" id="headerRepeat" min="3" max="20" value="5" step="1"></div>
            </div>
            
            <div class="param-grid" style="margin-top:8px;">
              <div><label>Sƒ±nav Kodu</label><input type="text" id="examId" value="SINAV-001"></div>
              <div><label>Web Adresi</label><input type="text" id="webUrl" value="optikform.com"></div>
            </div>
            
            <div class="btn-group">
              <button class="btn" id="refreshBtn">üîÑ Olu≈ütur</button>
              <button class="btn secondary" id="downloadPngBtn">üì• PNG ƒ∞ndir</button>
              <button class="btn secondary" id="downloadPdfBtn">üñ®Ô∏è Yazdƒ±r</button>
            </div>
          </div>
          
          <div class="card">
            <h3>üëÅÔ∏è √ñnizleme</h3>
            <div class="hint">Form canvas √ºzerine √ßizilir - PNG olarak indirilebilir</div>
            <div class="form-preview-wrap">
              <canvas id="formCanvas"></canvas>
            </div>
          </div>
        </div>
      </section>

      <!-- ===== READER ===== -->
      <section id="reader" class="view">
        <div class="grid">
          <div class="card">
            <h3>üîë Cevap Anahtarƒ±</h3>
            <div class="hint">Cevap anahtarƒ±nƒ± manuel girin veya form tarayarak y√ºkleyin</div>
            
            <div class="param-grid" style="margin-bottom:10px;">
              <div>
                <label>Anahtar Kaynaƒüƒ±</label>
                <select id="answerKeySource">
                  <option value="manual" selected>Manuel Giri≈ü</option>
                  <option value="scan">Tarayarak Y√ºkle</option>
                </select>
              </div>
              <div>
                <label>Soru Sayƒ±sƒ±</label>
                <input type="number" id="answerKeyCount" min="1" max="200" value="30">
              </div>
            </div>
            
            <div id="manualKeySection">
              <div class="btn-group" style="margin-bottom:8px;">
                <button class="btn secondary" id="generateKeyGridBtn" style="padding:6px 12px;font-size:11px;">üìã Anahtar Tablosu Olu≈ütur</button>
                <button class="btn secondary" id="clearKeyBtn" style="padding:6px 12px;font-size:11px;">üóëÔ∏è Temizle</button>
                <button class="btn secondary" id="randomKeyBtn" style="padding:6px 12px;font-size:11px;">üé≤ Rastgele</button>
              </div>
              <div class="answer-key-grid" id="answerKeyGrid">
                <!-- Dinamik olarak olu≈üturulacak -->
              </div>
            </div>
            
            <div id="scanKeySection" style="display:none;">
              <div class="btn-group">
                <button class="btn" id="scanKeyBtn">üì∑ Cevap Anahtarƒ± Tara</button>
              </div>
              <div class="hint" style="margin-top:8px;">Cevap anahtarƒ± formunu tarayƒ±n. ƒ∞≈üaretli cevaplar otomatik kaydedilecek.</div>
            </div>
            
            <div class="answer-key-status empty" id="answerKeyStatus">
              ‚ö†Ô∏è Cevap anahtarƒ± hen√ºz girilmedi
            </div>
          </div>
          
          <div class="card">
            <h3>üì∑ Form Okuma</h3>
            <div class="hint">Kamera veya dosyadan resim y√ºkleyerek formu okuyun</div>
            
            <div class="param-grid" style="margin-bottom:10px;">
              <div>
                <label>Kaynak</label>
                <select id="scanSource">
                  <option value="camera" selected>üì∑ Kamera</option>
                  <option value="file">üìÅ Dosyadan Y√ºkle</option>
                </select>
              </div>
            </div>
            
            <!-- Kamera B√∂l√ºm√º -->
            <div id="cameraSection">
              <div class="video-wrap">
                <video id="video" playsinline></video>
                <div class="overlay"></div>
                <div class="scan-status" id="scanStatus"><div class="dot"></div><span id="scanStatusText">Bekleniyor</span></div>
              </div>
              <div class="btn-group">
                <button class="btn" id="startCameraBtn">üì∑ Kamerayƒ± Ba≈ülat</button>
                <button class="btn secondary" id="captureBtn" disabled>üì∏ √ñƒürenci Formu Tara</button>
                <button class="btn secondary" id="autoScanBtn">üîÑ Otomatik</button>
              </div>
            </div>
            
            <!-- Dosya Y√ºkleme B√∂l√ºm√º -->
            <div id="fileSection" style="display:none;">
              <div style="border:2px dashed var(--border);border-radius:8px;padding:20px;text-align:center;margin-bottom:10px;">
                <input type="file" id="fileInput" accept="image/*" style="display:none;">
                <button class="btn" onclick="document.getElementById('fileInput').click()">üìÅ Resim Se√ß</button>
                <div class="hint" style="margin-top:8px;">PNG, JPG veya JPEG formatƒ±nda form resmi y√ºkleyin</div>
                <div id="fileName" style="margin-top:8px;font-size:11px;color:var(--muted);"></div>
              </div>
              <div class="btn-group">
                <button class="btn secondary" id="processFileBtn" disabled>üîç Formu Analiz Et</button>
                <button class="btn secondary" id="clearFileBtn" style="display:none;">üóëÔ∏è Temizle</button>
              </div>
            </div>
            
            <div class="settings-row">
              <label>E≈üik: <input type="number" id="fillThreshold" value="0.20" min="0.1" max="0.9" step="0.02"></label>
              <label>Ceza: <input type="number" id="penalty" value="0.25" min="0" max="1" step="0.05"></label>
            </div>
            <div class="log" id="cameraLog">Kaynak se√ßin ve formu y√ºkleyin.</div>
          </div>
          
          <div class="card">
            <h3>üìä Sonu√ßlar</h3>
            <div class="canvas-row">
              <div class="canvas-item"><div class="label">Yakalanan</div><canvas id="captureCanvas" class="process-canvas"></canvas></div>
              <div class="canvas-item"><div class="label">Marker</div><canvas id="markerCanvas" class="process-canvas"></canvas></div>
              <div class="canvas-item"><div class="label">D√ºzeltilmi≈ü</div><canvas id="warpCanvas" class="process-canvas"></canvas></div>
            </div>
            <div class="result-box" id="omrResult">
              <div class="summary">
                <div class="stat correct"><div class="stat-value">-</div><div class="stat-label">Doƒüru</div></div>
                <div class="stat wrong"><div class="stat-value">-</div><div class="stat-label">Yanlƒ±≈ü</div></div>
                <div class="stat"><div class="stat-value">-</div><div class="stat-label">Bo≈ü</div></div>
                <div class="stat net"><div class="stat-value">-</div><div class="stat-label">Net</div></div>
              </div>
              <div class="result-details" id="resultDetails">Sonu√ßlar burada...</div>
            </div>
            <div class="btn-group" style="margin-top:10px;">
              <button class="btn secondary" id="downloadTxtBtn" style="padding:6px 10px;font-size:11px;">TXT Listesi</button>
              <button class="btn secondary" id="downloadCsvBtn" style="padding:6px 10px;font-size:11px;">Excel (CSV)</button>
              <span id="sessionCount" style="font-size:11px;color:var(--muted);">0 kayit</span>
            </div>
            <div class="result-details" id="sessionList">Henuz kayit yok.</div>
            <div class="log" id="omrLog">Hazƒ±r.</div>
          </div>
        </div>
      </section>
    </main>
  </div>

  <script>
    // =====================================================
    // GLOBAL STATE
    // =====================================================
    const MARKER_OFFSET = 5;
    const MARKER_SIZE = 18;
    const MARKER_INNER = 6;
    const FILL_ROI_SCALE = 1.04; // Baloncuk ROI'sini hafif b√ºy√ºt, g√ºr√ºlt√º kapma riskini azalt
    const FILL_MASK_RATIO = 0.32; // ROI i√ßinde √∂l√ß√ºm yapƒ±lacak i√ß daire oranƒ± (√ßer√ßeveyi daha az say)
    const BLANK_GUARD = 0.18; // max skor bunun altƒ±ndaysa e≈üikten baƒüƒ±msƒ±z olarak Bo≈ü kabul et
    const sessionResults = [];
    let layoutConfig = null;
    let answerKey = {};
    let videoStream = null;
    let autoScanInterval = null;
    let isAutoScanning = false;
    let scanMode = 'student'; // 'student' veya 'answerKey'

    // =====================================================
    // INIT
    // =====================================================
    document.addEventListener('DOMContentLoaded', () => {
      setupTabs();
      setupInputs();
      generateForm();
      setupAnswerKeyUI();
      
      document.getElementById('refreshBtn').addEventListener('click', generateForm);
      document.getElementById('downloadPngBtn').addEventListener('click', downloadPNG);
      document.getElementById('downloadPdfBtn').addEventListener('click', () => window.print());
      document.getElementById('startCameraBtn').addEventListener('click', initCamera);
      document.getElementById('captureBtn').addEventListener('click', () => captureAndProcess());
      document.getElementById('autoScanBtn').addEventListener('click', toggleAutoScan);
      document.getElementById('downloadTxtBtn').addEventListener('click', downloadSessionTxt);
      document.getElementById('downloadCsvBtn').addEventListener('click', downloadSessionCsv);
      
      // Cevap anahtarƒ± event listener'larƒ±
      document.getElementById('answerKeySource').addEventListener('change', toggleAnswerKeyMode);
      document.getElementById('generateKeyGridBtn').addEventListener('click', generateAnswerKeyGrid);
      document.getElementById('clearKeyBtn').addEventListener('click', clearAnswerKey);
      document.getElementById('randomKeyBtn').addEventListener('click', generateRandomKey);
      document.getElementById('scanKeyBtn').addEventListener('click', startAnswerKeyScan);
      document.getElementById('answerKeyCount').addEventListener('change', generateAnswerKeyGrid);
      
      // Dosya y√ºkleme event listener'larƒ±
      document.getElementById('scanSource').addEventListener('change', toggleScanSource);
      document.getElementById('fileInput').addEventListener('change', handleFileSelect);
      document.getElementById('processFileBtn').addEventListener('click', processUploadedFile);
      document.getElementById('clearFileBtn').addEventListener('click', clearUploadedFile);
      
      renderSessionList();
    });

    function setupTabs() {
      document.querySelectorAll('.tabs button').forEach(btn => {
        btn.addEventListener('click', () => {
          document.querySelectorAll('.tabs button').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
          document.getElementById(btn.dataset.view).classList.add('active');
          if (btn.dataset.view === 'reader') initCamera();
        });
      });
    }

    function setupInputs() {
      const ids = ['questionCount', 'choiceCount', 'columnCount', 'studentDigits', 'showAnswerKey', 
                   'answerKeyChoices', 'formWidth', 'formHeight', 'bubbleSize', 'rowGap', 'examId', 'webUrl',
                   'qualityScale', 'headerRepeat'];
      ids.forEach(id => {
          const el = document.getElementById(id);
        if (el) el.addEventListener('input', debounce(generateForm, 200));
      });
    }

    function debounce(fn, delay) {
      let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), delay); };
    }

    function clampInt(v, min, max, def) {
      const n = parseInt(v, 10);
      return isNaN(n) ? def : Math.min(Math.max(n, min), max);
    }

    // =====================================================
    // FORM GENERATION - Canvas Based
    // =====================================================
    function generateForm() {
      const config = getConfig();
      layoutConfig = config;
      drawForm(config);
      generateAnswerKeyData(config);
    }

    function getConfig() {
      return {
        questionCount: clampInt(document.getElementById('questionCount').value, 1, 200, 30),
        choiceCount: clampInt(document.getElementById('choiceCount').value, 4, 5, 5),
        columnCount: clampInt(document.getElementById('columnCount').value, 1, 4, 2),
        studentDigits: clampInt(document.getElementById('studentDigits').value, 4, 15, 10),
        showAnswerKey: document.getElementById('showAnswerKey').value === 'yes',
        answerKeyChoices: clampInt(document.getElementById('answerKeyChoices').value, 4, 10, 10),
        formWidth: clampInt(document.getElementById('formWidth').value, 300, 1200, 600),
        formHeight: clampInt(document.getElementById('formHeight').value, 400, 2000, 900),
        bubbleSize: clampInt(document.getElementById('bubbleSize').value, 8, 24, 14),
        rowGap: clampInt(document.getElementById('rowGap').value, 1, 20, 4),
        qualityScale: clampInt(document.getElementById('qualityScale').value, 1, 4, 2),
        headerRepeat: clampInt(document.getElementById('headerRepeat').value, 3, 20, 5),
        examId: document.getElementById('examId').value || 'SINAV-001',
        webUrl: document.getElementById('webUrl').value || ''
      };
    }

    function drawForm(cfg) {
      const canvas = document.getElementById('formCanvas');
      const ctx = canvas.getContext('2d');
      
      // Y√ºksek kalite i√ßin √∂l√ßek fakt√∂r√º (kullanƒ±cƒ± ayarlƒ±)
      const scale = cfg.qualityScale;
      canvas.width = cfg.formWidth * scale;
      canvas.height = cfg.formHeight * scale;
      canvas.style.width = cfg.formWidth + 'px';
      canvas.style.height = cfg.formHeight + 'px';
      ctx.scale(scale, scale);
      
      // Background
      ctx.fillStyle = '#fff';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Border
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 2;
      ctx.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);
      
      // Corner markers
      // Not: ctx.scale() uygulandƒ±ƒüƒ± i√ßin orijinal boyutlarƒ± kullan
      drawCornerMarkers(ctx, cfg.formWidth, cfg.formHeight);
      
      const margin = 15;
      const bubbleR = cfg.bubbleSize / 2;
      const bubbleGap = cfg.bubbleSize + 3;
      const rowH = cfg.bubbleSize + cfg.rowGap;
      
      let y = margin + 10;
      
      // === HEADER: QR + √ñƒürenci No + Anahtar ===
      const qrSize = 60;
      
      // QR Code
      drawQRCode(ctx, margin, y, qrSize, cfg.examId);
      
      // Web URL under QR
      ctx.fillStyle = '#000';
      ctx.font = '8px Inter, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(cfg.webUrl, margin + qrSize/2, y + qrSize + 10);
      
      // === √ñƒürenci No Section ===
      const studentStartX = margin + qrSize + 15;
      const studentStartY = y;
      
      ctx.font = 'bold 9px Inter, sans-serif';
      ctx.textAlign = 'left';
      ctx.fillText('√ñƒürenci No.', studentStartX, studentStartY);
      
      // Draw student number grid (horizontal: digits, vertical: 0-9)
      const digitBubbleSize = Math.min(cfg.bubbleSize - 2, 12);
      const digitBubbleR = digitBubbleSize / 2;
      const digitGap = digitBubbleSize + 2;
      
      // Column headers (1, 2, 3, ...)
      ctx.font = '7px Inter, sans-serif';
      ctx.textAlign = 'center';
      for (let d = 0; d < cfg.studentDigits; d++) {
        const x = studentStartX + d * digitGap + digitBubbleR;
        ctx.fillStyle = '#000';
        // Draw box for column number
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 1;
        ctx.strokeRect(x - digitBubbleR, studentStartY + 5, digitBubbleSize, digitBubbleSize);
      }
      
      // 0-9 rows
      for (let row = 0; row < 10; row++) {
        const rowY = studentStartY + 20 + row * (digitBubbleSize + 2);
        
        // Row label (0-9)
        ctx.fillStyle = '#000';
        ctx.font = '8px Inter, sans-serif';
        ctx.textAlign = 'right';
        ctx.fillText(row.toString(), studentStartX - 4, rowY + digitBubbleR + 3);
        
        // Bubbles for each digit position
        for (let col = 0; col < cfg.studentDigits; col++) {
          const x = studentStartX + col * digitGap + digitBubbleR;
          drawBubble(ctx, x, rowY + digitBubbleR, digitBubbleR - 1);
        }
      }
      
      // === Cevap Anahtarƒ± Section (if enabled) ===
      if (cfg.showAnswerKey) {
        const keyStartX = studentStartX + cfg.studentDigits * digitGap + 20;
        const keyStartY = studentStartY;
        
        ctx.font = 'bold 9px Inter, sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText('Anahtar', keyStartX, keyStartY);
        
        // A, B, C, D, E... labels
        const letters = 'ABCDEFGHIJ'.split('');
        ctx.font = '7px Inter, sans-serif';
        ctx.textAlign = 'center';
        
        for (let i = 0; i < cfg.answerKeyChoices; i++) {
          const rowY = keyStartY + 10 + i * (digitBubbleSize + 2);
          
          // Letter label
          ctx.fillStyle = '#000';
          ctx.textAlign = 'right';
          ctx.fillText(letters[i], keyStartX - 4, rowY + digitBubbleR + 3);
          
          // Single bubble
          drawBubble(ctx, keyStartX + digitBubbleR, rowY + digitBubbleR, digitBubbleR - 1);
        }
      }
      
      // Header section height
      const headerHeight = 20 + 10 * (digitBubbleSize + 2) + 15;
      y = studentStartY + headerHeight;
      
      // Horizontal line separator
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(margin, y);
      ctx.lineTo(canvas.width - margin, y);
      ctx.stroke();
      
      y += 10;
      
      // === QUESTIONS SECTION ===
      const questionsPerColumn = Math.ceil(cfg.questionCount / cfg.columnCount);
      // Not: canvas.width scale edilmi≈ü, √ßizimde cfg.formWidth kullanmalƒ±yƒ±z
      const columnWidth = (cfg.formWidth - margin * 2) / cfg.columnCount;
      
      // Store bubble positions for OMR
      layoutConfig.questions = [];
      layoutConfig.studentId = { digits: cfg.studentDigits, bubbles: [] };
      
      // Store student ID bubble positions (scale fakt√∂r√ºn√º hesaba kat)
      for (let row = 0; row < 10; row++) {
        for (let col = 0; col < cfg.studentDigits; col++) {
          const bx = (studentStartX + col * digitGap + digitBubbleR) / cfg.formWidth;
          const by = (studentStartY + 20 + row * (digitBubbleSize + 2) + digitBubbleR) / cfg.formHeight;
          layoutConfig.studentId.bubbles.push({
            digit: row, col, x: bx, y: by, width: digitBubbleSize / cfg.formWidth, height: digitBubbleSize / cfg.formHeight
          });
        }
      }
      
      const letters = 'ABCDE'.split('').slice(0, cfg.choiceCount);
      const headerRepeatInterval = cfg.headerRepeat; // Her N soruda bir harf ba≈ülƒ±klarƒ± tekrarla
      
      for (let col = 0; col < cfg.columnCount; col++) {
        const colX = margin + col * columnWidth;
        const labelStartX = colX + 25;
        
        // ƒ∞lk s√ºtun ba≈ülƒ±ƒüƒ± (A B C D E)
        ctx.font = '8px Inter, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#666';
        for (let i = 0; i < letters.length; i++) {
          ctx.fillText(letters[i], labelStartX + i * bubbleGap, y);
        }
        
        // Draw questions
        let extraOffset = 0; // Eklenen ba≈ülƒ±klar i√ßin ekstra offset
        
        for (let qIdx = 0; qIdx < questionsPerColumn; qIdx++) {
          const qNum = col * questionsPerColumn + qIdx + 1;
          if (qNum > cfg.questionCount) break;
          
          // Her 5 soruda bir (ba≈ülangƒ±√ß hari√ß) harf ba≈ülƒ±klarƒ±nƒ± tekrarla
          if (qIdx > 0 && qIdx % headerRepeatInterval === 0) {
            extraOffset += rowH * 0.8;
            const headerY = y + 12 + qIdx * rowH + extraOffset - rowH * 0.6;
            
            ctx.font = '8px Inter, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#666';
            for (let i = 0; i < letters.length; i++) {
              ctx.fillText(letters[i], labelStartX + i * bubbleGap, headerY);
            }
          }
          
          const qY = y + 12 + qIdx * rowH + extraOffset;
          
          // Question number
          ctx.fillStyle = '#000';
          ctx.font = 'bold 9px Inter, sans-serif';
          ctx.textAlign = 'right';
          ctx.fillText(qNum.toString(), colX + 18, qY + bubbleR + 3);
          
          // Choice bubbles
          const choices = [];
          for (let c = 0; c < cfg.choiceCount; c++) {
            const bx = labelStartX + c * bubbleGap;
            drawBubble(ctx, bx, qY + bubbleR, bubbleR - 1);
            
            choices.push({
              option: letters[c],
              x: bx / cfg.formWidth,
              y: (qY + bubbleR) / cfg.formHeight,
              width: cfg.bubbleSize / cfg.formWidth,
              height: cfg.bubbleSize / cfg.formHeight
            });
          }
          
          layoutConfig.questions.push({ questionNumber: qNum, choices });
        }
      }
      
      // Store dimensions for OMR (orijinal boyutlar, scale'siz)
      layoutConfig.canvasWidth = cfg.formWidth;
      layoutConfig.canvasHeight = cfg.formHeight;
    }

    function drawCornerMarkers(ctx, w, h) {
      ctx.fillStyle = '#000';
      
      // Top-left
      ctx.fillRect(MARKER_OFFSET, MARKER_OFFSET, MARKER_SIZE, MARKER_SIZE);
      ctx.fillStyle = '#fff';
      ctx.fillRect(
        MARKER_OFFSET + MARKER_SIZE - MARKER_INNER,
        MARKER_OFFSET + MARKER_SIZE - MARKER_INNER,
        MARKER_INNER,
        MARKER_INNER
      );
      
      // Top-right
      ctx.fillStyle = '#000';
      ctx.fillRect(w - MARKER_OFFSET - MARKER_SIZE, MARKER_OFFSET, MARKER_SIZE, MARKER_SIZE);
      ctx.fillStyle = '#fff';
      ctx.fillRect(
        w - MARKER_OFFSET - MARKER_SIZE,
        MARKER_OFFSET + MARKER_SIZE - MARKER_INNER,
        MARKER_INNER,
        MARKER_INNER
      );
      
      // Bottom-left
      ctx.fillStyle = '#000';
      ctx.fillRect(MARKER_OFFSET, h - MARKER_OFFSET - MARKER_SIZE, MARKER_SIZE, MARKER_SIZE);
      ctx.fillStyle = '#fff';
      ctx.fillRect(
        MARKER_OFFSET + MARKER_SIZE - MARKER_INNER,
        h - MARKER_OFFSET - MARKER_SIZE,
        MARKER_INNER,
        MARKER_INNER
      );
      
      // Bottom-right
      ctx.fillStyle = '#000';
      ctx.fillRect(w - MARKER_OFFSET - MARKER_SIZE, h - MARKER_OFFSET - MARKER_SIZE, MARKER_SIZE, MARKER_SIZE);
      ctx.fillStyle = '#fff';
      ctx.fillRect(
        w - MARKER_OFFSET - MARKER_SIZE,
        h - MARKER_OFFSET - MARKER_SIZE,
        MARKER_INNER,
        MARKER_INNER
      );
    }

    function drawBubble(ctx, x, y, r) {
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 1.2;
      ctx.stroke();
    }

    function drawQRCode(ctx, x, y, size, data) {
      // Create temporary container for QR
      const tempDiv = document.createElement('div');
      tempDiv.style.position = 'absolute';
      tempDiv.style.left = '-9999px';
      document.body.appendChild(tempDiv);
      
      const qr = new QRCode(tempDiv, {
        text: data,
        width: size,
        height: size,
        correctLevel: QRCode.CorrectLevel.M
      });
      
      // Wait for QR to render then draw to canvas
      setTimeout(() => {
        const qrImg = tempDiv.querySelector('img');
        if (qrImg && qrImg.complete) {
          ctx.drawImage(qrImg, x, y, size, size);
        } else {
          const qrCanvas = tempDiv.querySelector('canvas');
          if (qrCanvas) {
            ctx.drawImage(qrCanvas, x, y, size, size);
          }
        }
        document.body.removeChild(tempDiv);
      }, 100);
      
      // Draw border
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 1;
      ctx.strokeRect(x, y, size, size);
    }

    function generateAnswerKeyData(cfg) {
      answerKey = {};
      const letters = ['A', 'B', 'C', 'D', 'E'];
      for (let i = 1; i <= cfg.questionCount; i++) {
        answerKey[i] = letters[(i - 1) % cfg.choiceCount];
      }
    }

    function downloadPNG() {
      const canvas = document.getElementById('formCanvas');
      const link = document.createElement('a');
      link.download = `optik-form-${layoutConfig.examId}.png`;
      // Y√ºksek kaliteli PNG (varsayƒ±lan olarak zaten en iyi kalite)
      link.href = canvas.toDataURL('image/png', 1.0);
      link.click();
    }

    // =====================================================
    // CAMERA & OMR
    // =====================================================
    async function initCamera() {
      try {
        if (videoStream) return;
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } }
        });
        videoStream = stream;
        document.getElementById('video').srcObject = stream;
        await document.getElementById('video').play();
        document.getElementById('captureBtn').disabled = false;
        updateStatus('ready', 'Hazƒ±r');
        setLog('cameraLog', '‚úì Kamera hazƒ±r', 'success');
      } catch (e) {
        setLog('cameraLog', '‚úó Kamera hatasƒ±: ' + e.message, 'error');
      }
    }

    function updateStatus(state, text) {
      const el = document.getElementById('scanStatus');
      el.className = 'scan-status ' + state;
      document.getElementById('scanStatusText').textContent = text;
    }

    function setLog(id, msg, type = '') {
      const el = document.getElementById(id);
      el.textContent = msg;
      el.className = 'log ' + type;
    }

    function toggleAutoScan() {
      if (isAutoScanning) {
        clearInterval(autoScanInterval);
        isAutoScanning = false;
        document.getElementById('autoScanBtn').textContent = 'üîÑ Otomatik';
      } else {
        isAutoScanning = true;
        document.getElementById('autoScanBtn').textContent = '‚èπÔ∏è Durdur';
        autoScanInterval = setInterval(() => captureAndProcess(true), 800);
      }
    }

    function processFrame(isAuto) {
      let src, gray, blurred, binary, markerOverlay;
      
      try {
        src = cv.imread('captureCanvas');
        gray = new cv.Mat(); cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
        blurred = new cv.Mat(); cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);
        binary = new cv.Mat(); cv.adaptiveThreshold(blurred, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 11, 2);
        
        markerOverlay = src.clone();
        const markers = detectCornerMarkers(binary, markerOverlay);
        cv.imshow('markerCanvas', markerOverlay);
        
        if (!markers) {
          updateStatus('', 'Form bulunamadƒ±');
          if (!isAuto) setLog('omrLog', 'K√∂≈üe markerlarƒ± bulunamadƒ±', 'error');
          return;
        }
        
        const warped = warpPerspective(src, markers);
      cv.imshow('warpCanvas', warped);

        const result = analyzeBubbles(warped);
      renderResults(result);
      addSessionResult(result);
        
        if (isAuto && result.correct + result.wrong > 0) {
          toggleAutoScan();
        }
        
        updateStatus('ready', '‚úì Okundu');
        setLog('omrLog', '‚úì Tarama tamamlandƒ±', 'success');
        
        warped.delete();
      } catch (e) {
        if (!isAuto) setLog('omrLog', 'Hata: ' + e.message, 'error');
      } finally {
        if (src) src.delete();
        if (gray) gray.delete();
        if (blurred) blurred.delete();
        if (binary) binary.delete();
        if (markerOverlay) markerOverlay.delete();
      }
    }

    function detectCornerMarkers(binary, overlay) {
      const contours = new cv.MatVector();
      const hierarchy = new cv.Mat();
      cv.findContours(binary, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
      
      const candidates = [];
      const imgArea = binary.rows * binary.cols;
      
      for (let i = 0; i < contours.size(); i++) {
        const cnt = contours.get(i);
        const area = cv.contourArea(cnt);
        if (area < imgArea * 0.0003 || area > imgArea * 0.02) continue;
        
        const rect = cv.boundingRect(cnt);
        const aspect = rect.width / rect.height;
        if (aspect > 0.5 && aspect < 2) {
          const hull = new cv.Mat();
          cv.convexHull(cnt, hull);
          const solidity = area / cv.contourArea(hull);
          hull.delete();
          
          if (solidity > 0.6) {
            candidates.push({
              center: { x: rect.x + rect.width/2, y: rect.y + rect.height/2 },
              rect
            });
          }
        }
      }
      
      contours.delete(); hierarchy.delete();
      if (candidates.length < 4) return null;
      
      const cx = binary.cols / 2, cy = binary.rows / 2;
      let tl, tr, bl, br;
      let tlD = Infinity, trD = Infinity, blD = Infinity, brD = Infinity;
      
      for (const c of candidates) {
        const left = c.center.x < cx, top = c.center.y < cy;
        const d = (x, y) => Math.hypot(c.center.x - x, c.center.y - y);
        
        if (left && top && d(0, 0) < tlD) { tlD = d(0, 0); tl = c; }
        if (!left && top && d(binary.cols, 0) < trD) { trD = d(binary.cols, 0); tr = c; }
        if (left && !top && d(0, binary.rows) < blD) { blD = d(0, binary.rows); bl = c; }
        if (!left && !top && d(binary.cols, binary.rows) < brD) { brD = d(binary.cols, binary.rows); br = c; }
      }
      
      if (!tl || !tr || !bl || !br) return null;
      
      // Draw markers
      const green = new cv.Scalar(0, 255, 0, 255);
      [tl, tr, bl, br].forEach(m => {
        cv.rectangle(overlay, new cv.Point(m.rect.x, m.rect.y), 
                     new cv.Point(m.rect.x + m.rect.width, m.rect.y + m.rect.height), green, 2);
      });
      
      return {
        tl: tl.center,
        tr: tr.center,
        bl: bl.center,
        br: br.center
      };
    }

    function warpPerspective(src, markers) {
      const W = layoutConfig.canvasWidth || 600;
      const H = layoutConfig.canvasHeight || 900;
      const markerCenter = MARKER_OFFSET + MARKER_SIZE / 2;
      
      const srcPts = cv.matFromArray(4, 1, cv.CV_32FC2, [
        markers.tl.x, markers.tl.y, markers.tr.x, markers.tr.y,
        markers.br.x, markers.br.y, markers.bl.x, markers.bl.y
      ]);
      const dstPts = cv.matFromArray(4, 1, cv.CV_32FC2, [
        markerCenter, markerCenter,
        W - markerCenter, markerCenter,
        W - markerCenter, H - markerCenter,
        markerCenter, H - markerCenter
      ]);
      const M = cv.getPerspectiveTransform(srcPts, dstPts);
      const dst = new cv.Mat();
      cv.warpPerspective(src, dst, M, new cv.Size(W, H));
      srcPts.delete(); dstPts.delete(); M.delete();
      return dst;
    }

    function analyzeBubbles(warpMat, debugDraw = true) {
      const threshold = parseFloat(document.getElementById('fillThreshold').value) || 0.20;
      const penalty = parseFloat(document.getElementById('penalty').value) || 0.25;
      
      const gray = new cv.Mat(); cv.cvtColor(warpMat, gray, cv.COLOR_RGBA2GRAY);
      // Daha k√º√ß√ºk blok ve d√º≈ü√ºk C: lekeler/parlamalar daha az doldurulur
      const binary = new cv.Mat(); cv.adaptiveThreshold(gray, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 11, 2);
      
      const w = warpMat.cols, h = warpMat.rows;
      let correct = 0, wrong = 0, blank = 0, multi = 0;
      const perQuestion = [];
      
      // Debug: ROI'leri √ßizmek i√ßin warpMat'in kopyasƒ±nƒ± al
      let debugMat = null;
      if (debugDraw) {
        debugMat = warpMat.clone();
      }
      
      console.log(`Warp boyutu: ${w}x${h}, Layout boyutu: ${layoutConfig.canvasWidth}x${layoutConfig.canvasHeight}`);
      console.log(`Toplam soru: ${layoutConfig.questions.length}`);
      
      for (const q of layoutConfig.questions) {
        const scores = q.choices.map(c => {
          // ROI boyutlarƒ±nƒ± hesapla
          const roiW = Math.round(c.width * w * FILL_ROI_SCALE);
          const roiH = Math.round(c.height * h * FILL_ROI_SCALE);
          
          // Merkez koordinatlarƒ±ndan sol √ºst k√∂≈üeyi hesapla
          const rectX = Math.max(0, Math.round(c.x * w - roiW / 2));
          const rectY = Math.max(0, Math.round(c.y * h - roiH / 2));
          
          const rect = new cv.Rect(rectX, rectY, roiW, roiH);
          
          // Sƒ±nƒ±r kontrol√º
          if (rect.x + rect.width > w) rect.width = w - rect.x;
          if (rect.y + rect.height > h) rect.height = h - rect.y;
          if (rect.width <= 0 || rect.height <= 0) return { opt: c.option, score: 0 };
          
          // Debug: ROI'yi √ßiz
          if (debugMat && q.questionNumber <= 5) {
            const color = new cv.Scalar(0, 255, 0, 255); // Ye≈üil
            cv.rectangle(debugMat, new cv.Point(rect.x, rect.y), 
                        new cv.Point(rect.x + rect.width, rect.y + rect.height), color, 1);
          }
          
          const roi = binary.roi(rect);
          let score = 0;
          // Dairesel maske ile i? b?lgeyi oku (?er?eve ?izgisini hari? tut)
          if (roi.rows > 0 && roi.cols > 0) {
            const mask = new cv.Mat.zeros(roi.rows, roi.cols, cv.CV_8UC1);
            const r = Math.floor(Math.min(roi.rows, roi.cols) * FILL_MASK_RATIO);
            const cx = Math.floor(roi.cols / 2);
            const cy = Math.floor(roi.rows / 2);
            cv.circle(mask, new cv.Point(cx, cy), r, new cv.Scalar(255, 255, 255, 255), -1);
            const masked = new cv.Mat();
            cv.bitwise_and(roi, mask, masked);
            const maskArea = cv.countNonZero(mask);
            score = maskArea > 0 ? cv.countNonZero(masked) / maskArea : 0;
            masked.delete(); mask.delete();
          }
          roi.delete();
          
          // Debug log for first question
          if (q.questionNumber === 1) {
            console.log(`S1 ${c.option}: rect(${rect.x},${rect.y},${rect.width},${rect.height}) score=${score.toFixed(3)}`);
          }
          
          return { opt: c.option, score };
        });
        
        // En y√ºksek skora sahip olanƒ± bul
        const maxScore = Math.max(...scores.map(s => s.score));
        // G√ºr√ºlt√º alt sƒ±nƒ±rƒ±: max skor √ßok d√º≈ü√ºkse doƒürudan bo≈ü kabul et
        if (maxScore < BLANK_GUARD) {
          blank++;
          perQuestion.push({ q: q.questionNumber, marked: '-', status: 'Bo≈ü', maxScore: maxScore.toFixed(2) });
          continue;
        }

        const filled = scores.filter(s => s.score >= threshold);
        
        let status = 'Bo≈ü';
        let candidate = null;
        let markedLabel = '-';
        
        // Tek se√ßim i√ßin: en y√ºksek skor threshold'u ge√ßmese bile,
        // belirgin ≈üekilde diƒüerlerinden y√ºksekse al
        if (filled.length === 0 && maxScore > 0.05) {
          const sortedScores = [...scores].sort((a, b) => b.score - a.score);
          const best = sortedScores[0];
          const second = sortedScores[1];
          // En y√ºksek, ikinciden en az %50 daha y√ºksekse
          if (best.score > second.score * 1.5 || (best.score > 0.1 && best.score > second.score * 1.3)) {
            candidate = best;
          }
        } else if (filled.length > 1) {
          // √áoklu i≈üaret varsa en y√ºksek skorlu se√ßeneƒüi al
          candidate = filled.reduce((a, b) => (a.score >= b.score ? a : b));
          if (candidate) markedLabel = candidate.opt + '*';
          multi++;
        } else if (filled.length === 1) {
          candidate = filled[0];
        }
        
        if (candidate) {
          const key = answerKey[q.questionNumber];
          status = key === candidate.opt ? 'Doƒüru' : 'Yanlƒ±≈ü';
          if (markedLabel === '-') markedLabel = candidate.opt;
          if (status === 'Doƒüru') correct++; else wrong++;
        } else {
          blank++;
        }
        
        perQuestion.push({ q: q.questionNumber, marked: markedLabel, status, maxScore: maxScore.toFixed(2) });
      }
      
      // Debug g√∂r√ºnt√ºs√ºn√º g√∂ster
      if (debugMat) {
        cv.imshow('warpCanvas', debugMat);
        debugMat.delete();
      }
      
      // Read student ID
      let studentNo = '';
      if (layoutConfig.studentId) {
        for (let col = 0; col < layoutConfig.studentId.digits; col++) {
          const colBubbles = layoutConfig.studentId.bubbles.filter(b => b.col === col);
          let best = null, bestScore = 0;
        for (const b of colBubbles) {
          const rect = new cv.Rect(
              Math.max(0, Math.round(b.x * w - b.width * w / 2)),
              Math.max(0, Math.round(b.y * h - b.height * h / 2)),
              Math.round(b.width * w), Math.round(b.height * h)
            );
            if (rect.x + rect.width > w || rect.y + rect.height > h) continue;
          const roi = binary.roi(rect);
            const score = cv.countNonZero(roi) / (rect.width * rect.height);
          roi.delete();
            if (score > bestScore) { bestScore = score; best = b.digit; }
          }
          studentNo += bestScore >= threshold ? best : '?';
        }
      }
      
      gray.delete(); binary.delete();
      
      const net = (correct - wrong * penalty).toFixed(2);
      return { correct, wrong, blank, multi, net, perQuestion, studentNo };
    }

    function renderResults(r) {
      document.querySelector('.stat.correct .stat-value').textContent = r.correct;
      document.querySelector('.stat.wrong .stat-value').textContent = r.wrong;
      document.querySelectorAll('.stat')[2].querySelector('.stat-value').textContent = r.blank;
      document.querySelector('.stat.net .stat-value').textContent = r.net;
      
      let html = r.studentNo ? `<div style="margin-bottom:8px;border-bottom:1px solid var(--border);padding-bottom:6px;"><b>√ñƒürenci No:</b> ${r.studentNo}</div>` : '';
      html += r.perQuestion.map(p => {
        const color = p.status === 'Doƒüru' ? '#10b981' : p.status === 'Yanlƒ±≈ü' ? '#ef4444' : p.status === 'Bo≈ü' ? '#666' : '#f59e0b';
        const scoreInfo = p.maxScore ? ` <span style="color:#666;font-size:9px;">(${p.maxScore})</span>` : '';
        return `<div><span style="width:25px;display:inline-block;text-align:right;">${p.q}.</span> ${p.marked}${scoreInfo} <span style="color:${color}">${p.status}</span></div>`;
      }).join('');
      
      document.getElementById('resultDetails').innerHTML = html;
    }

    // =====================================================
    // SESSION LOG / EXPORT
    // =====================================================
    function addSessionResult(r) {
      const entry = {
        id: sessionResults.length + 1,
        studentNo: (r.studentNo && !r.studentNo.includes('?')) ? r.studentNo : 'Bilinmiyor',
        correct: r.correct,
        wrong: r.wrong,
        blank: r.blank,
        multi: r.multi,
        net: r.net,
        perQuestion: r.perQuestion.map(p => ({ ...p }))
      };
      sessionResults.push(entry);
      renderSessionList();
    }

    function renderSessionList() {
      const listEl = document.getElementById('sessionList');
      const countEl = document.getElementById('sessionCount');
      if (!listEl) return;
      if (countEl) countEl.textContent = `${sessionResults.length} kayit`;
      if (sessionResults.length === 0) {
        listEl.textContent = 'Henuz kayit yok.';
        return;
      }
      const recent = sessionResults.slice(-8).reverse();
      listEl.innerHTML = recent.map(r => {
        return `<div>#${r.id} - ${r.studentNo || 'Bilinmiyor'} | D:${r.correct} Y:${r.wrong} B:${r.blank} C:${r.multi} Net:${r.net}</div>`;
      }).join('');
    }

    function downloadSessionTxt() {
      if (sessionResults.length === 0) { alert('Kayit yok.'); return; }
      const lines = sessionResults.map(r => {
        const answers = (r.perQuestion || []).map(p => p.marked || '-').join('');
        return `#${r.id}	${r.studentNo || 'Bilinmiyor'}	D:${r.correct}	Y:${r.wrong}	B:${r.blank}	Coklu:${r.multi}	Net:${r.net}	Cevaplar:${answers}`;
      });
      const blob = new Blob([lines.join('\n')], { type: 'text/plain;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'oturum-listesi.txt';
      a.click();
      URL.revokeObjectURL(url);
    }

    function csvEscape(v) {
      const s = v === undefined || v === null ? '' : String(v);
      return '"' + s.replace(/"/g, '""') + '"';
    }

    function downloadSessionCsv() {
      if (sessionResults.length === 0) { alert('Kayit yok.'); return; }
      const maxQ = Math.max(...sessionResults.map(r => (r.perQuestion || []).length || 0));
      const header = ['Sira','OgrenciNo','Dogru','Yanlis','Bos','Coklu','Net'];
      for (let i = 1; i <= maxQ; i++) header.push(`S${i}`);
      const rows = sessionResults.map(r => {
        const base = [r.id, r.studentNo || '', r.correct, r.wrong, r.blank, r.multi, r.net];
        const answers = r.perQuestion || [];
        for (let i = 0; i < maxQ; i++) {
          base.push(answers[i] ? (answers[i].marked || '') : '');
        }
        return base.map(csvEscape).join(',');
      });
      const csv = [header.map(csvEscape).join(','), ...rows].join('\n');
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'oturum-sonuclari.csv';
      a.click();
      URL.revokeObjectURL(url);
    }

    // =====================================================
    // CEVAP ANAHTARI Y√ñNETƒ∞Mƒ∞
    // =====================================================
    
    function setupAnswerKeyUI() {
      generateAnswerKeyGrid();
      updateAnswerKeyStatus();
    }
    
    function toggleAnswerKeyMode() {
      const source = document.getElementById('answerKeySource').value;
      document.getElementById('manualKeySection').style.display = source === 'manual' ? 'block' : 'none';
      document.getElementById('scanKeySection').style.display = source === 'scan' ? 'block' : 'none';
    }
    
    function generateAnswerKeyGrid() {
      const count = clampInt(document.getElementById('answerKeyCount').value, 1, 200, 30);
      const choiceCount = clampInt(document.getElementById('choiceCount')?.value || 5, 4, 5, 5);
      const grid = document.getElementById('answerKeyGrid');
      const letters = ['A', 'B', 'C', 'D', 'E'].slice(0, choiceCount);
      
      let html = '';
      for (let i = 1; i <= count; i++) {
        const currentAnswer = answerKey[i] || '';
        html += `<div class="answer-key-item">
          <span>${i}.</span>
          <select data-question="${i}" onchange="updateSingleAnswer(${i}, this.value)">
            <option value="">-</option>
            ${letters.map(l => `<option value="${l}" ${currentAnswer === l ? 'selected' : ''}>${l}</option>`).join('')}
          </select>
        </div>`;
      }
      
      grid.innerHTML = html;
      updateAnswerKeyStatus();
    }
    
    function updateSingleAnswer(questionNum, answer) {
      if (answer) {
        answerKey[questionNum] = answer;
      } else {
        delete answerKey[questionNum];
      }
      updateAnswerKeyStatus();
    }
    
    function clearAnswerKey() {
      answerKey = {};
      generateAnswerKeyGrid();
      updateAnswerKeyStatus();
    }
    
    function generateRandomKey() {
      const count = clampInt(document.getElementById('answerKeyCount').value, 1, 200, 30);
      const choiceCount = clampInt(document.getElementById('choiceCount')?.value || 5, 4, 5, 5);
      const letters = ['A', 'B', 'C', 'D', 'E'].slice(0, choiceCount);
      
      answerKey = {};
      for (let i = 1; i <= count; i++) {
        answerKey[i] = letters[Math.floor(Math.random() * letters.length)];
      }
      
      generateAnswerKeyGrid();
      updateAnswerKeyStatus();
    }
    
    function updateAnswerKeyStatus() {
      const count = clampInt(document.getElementById('answerKeyCount').value, 1, 200, 30);
      const filledCount = Object.keys(answerKey).length;
      const statusEl = document.getElementById('answerKeyStatus');
      
      if (filledCount === 0) {
        statusEl.className = 'answer-key-status empty';
        statusEl.innerHTML = '‚ö†Ô∏è Cevap anahtarƒ± hen√ºz girilmedi';
      } else if (filledCount < count) {
        statusEl.className = 'answer-key-status empty';
        statusEl.innerHTML = `‚ö†Ô∏è ${filledCount}/${count} soru cevaplandƒ± - eksik cevaplar var`;
      } else {
        statusEl.className = 'answer-key-status';
        statusEl.innerHTML = `‚úÖ Cevap anahtarƒ± hazƒ±r (${filledCount} soru)`;
      }
    }
    
    function startAnswerKeyScan() {
      scanMode = 'answerKey';
      const source = document.getElementById('scanSource').value;
      if (source === 'camera') {
        document.getElementById('captureBtn').textContent = 'üì∑ Cevap Anahtarƒ± Tara';
        setLog('cameraLog', 'üìã Cevap anahtarƒ± formunu tarayƒ±n...', 'success');
      } else {
        document.getElementById('processFileBtn').textContent = 'üîë Cevap Anahtarƒ± Analiz Et';
        setLog('cameraLog', 'üìã Cevap anahtarƒ± resmini y√ºkleyin ve analiz edin...', 'success');
      }
      updateStatus('ready', 'Anahtar Tarama');
    }
    
    function captureAndProcess(isAuto = false) {
      if (!cvReady) { setLog('omrLog', 'OpenCV bekleniyor...', 'error'); return; }
      
      const video = document.getElementById('video');
      if (!video || video.readyState < 2) return;
      
      const canvas = document.getElementById('captureCanvas');
      const ctx = canvas.getContext('2d');
      canvas.width = Math.min(640, video.videoWidth);
      canvas.height = Math.floor(canvas.width * video.videoHeight / video.videoWidth);
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      
      if (scanMode === 'answerKey') {
        processAnswerKeyFrame();
      } else {
        processFrame(isAuto);
      }
    }
    
    function processAnswerKeyFrame() {
      let src, gray, blurred, binary, markerOverlay;
      
      try {
        src = cv.imread('captureCanvas');
        gray = new cv.Mat(); cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
        blurred = new cv.Mat(); cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);
        binary = new cv.Mat(); cv.adaptiveThreshold(blurred, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 11, 2);
        
        markerOverlay = src.clone();
        const markers = detectCornerMarkers(binary, markerOverlay);
        cv.imshow('markerCanvas', markerOverlay);
        
        if (!markers) {
          setLog('cameraLog', '‚ö†Ô∏è K√∂≈üe markerlarƒ± bulunamadƒ±', 'error');
          return;
        }
        
        const warped = warpPerspective(src, markers);
        cv.imshow('warpCanvas', warped);
        
        // Cevap anahtarƒ±nƒ± oku
        const result = readAnswerKeyFromScan(warped);
        
        if (result.success) {
          answerKey = result.answers;
          generateAnswerKeyGrid();
          updateAnswerKeyStatus();
          
          // Normal tarama moduna geri d√∂n
          scanMode = 'student';
          document.getElementById('captureBtn').textContent = 'üì∏ √ñƒürenci Formu Tara';
          setLog('cameraLog', `‚úÖ Cevap anahtarƒ± y√ºklendi! ${Object.keys(answerKey).length} cevap okundu.`, 'success');
          updateStatus('ready', '‚úì Anahtar Y√ºklendi');
        } else {
          setLog('cameraLog', '‚ö†Ô∏è Cevap anahtarƒ± okunamadƒ±, tekrar deneyin', 'error');
        }
        
        warped.delete();
      } catch (e) {
        setLog('cameraLog', 'Hata: ' + e.message, 'error');
      } finally {
        if (src) src.delete();
        if (gray) gray.delete();
        if (blurred) blurred.delete();
        if (binary) binary.delete();
        if (markerOverlay) markerOverlay.delete();
      }
    }
    
    function readAnswerKeyFromScan(warpMat) {
      const threshold = parseFloat(document.getElementById('fillThreshold').value) || 0.28;
      
      const gray = new cv.Mat(); cv.cvtColor(warpMat, gray, cv.COLOR_RGBA2GRAY);
      const binary = new cv.Mat(); cv.adaptiveThreshold(gray, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 15, 4);
      
      const w = warpMat.cols, h = warpMat.rows;
      const answers = {};
      let successCount = 0;
      
      // ROI boyut √ßarpanƒ±
      const roiScale = 1.3;
      
      for (const q of layoutConfig.questions) {
        const scores = q.choices.map(c => {
          const roiW = Math.round(c.width * w * roiScale);
          const roiH = Math.round(c.height * h * roiScale);
          
          const rect = new cv.Rect(
            Math.max(0, Math.round(c.x * w - roiW / 2)),
            Math.max(0, Math.round(c.y * h - roiH / 2)),
            roiW,
            roiH
          );
          
          // Sƒ±nƒ±r kontrol√º
          if (rect.x + rect.width > w) rect.width = w - rect.x;
          if (rect.y + rect.height > h) rect.height = h - rect.y;
          if (rect.width <= 0 || rect.height <= 0) return { opt: c.option, score: 0 };
          
          const roi = binary.roi(rect);
          let score = 0;
          // Dairesel maske ile i? b?lgeyi oku (?er?eve ?izgisini hari? tut)
          if (roi.rows > 0 && roi.cols > 0) {
            const mask = new cv.Mat.zeros(roi.rows, roi.cols, cv.CV_8UC1);
            const r = Math.floor(Math.min(roi.rows, roi.cols) * FILL_MASK_RATIO);
            const cx = Math.floor(roi.cols / 2);
            const cy = Math.floor(roi.rows / 2);
            cv.circle(mask, new cv.Point(cx, cy), r, new cv.Scalar(255, 255, 255, 255), -1);
            const masked = new cv.Mat();
            cv.bitwise_and(roi, mask, masked);
            const maskArea = cv.countNonZero(mask);
            score = maskArea > 0 ? cv.countNonZero(masked) / maskArea : 0;
            masked.delete(); mask.delete();
          }
          roi.delete();
          return { opt: c.option, score };
        });
        
        // En y√ºksek skora sahip ≈üƒ±kkƒ± bul
        const maxScore = Math.max(...scores.map(s => s.score));
        const filled = scores.filter(s => s.score >= threshold);
        
        // Tek i≈üaretli cevap varsa al
        if (filled.length === 1) {
          answers[q.questionNumber] = filled[0].opt;
          successCount++;
        } 
        // Hi√ßbiri threshold'u ge√ßmiyorsa ama belirgin bir i≈üaret varsa
        else if (filled.length === 0 && maxScore >= threshold * 0.6) {
          const best = scores.find(s => s.score === maxScore);
          // Diƒüerlerinden belirgin ≈üekilde y√ºksek olmalƒ±
          const secondMax = Math.max(...scores.filter(s => s.score !== maxScore).map(s => s.score));
          if (best && maxScore > secondMax * 1.5) {
            answers[q.questionNumber] = best.opt;
            successCount++;
          }
        }
      }
      
      gray.delete(); binary.delete();
      
      console.log(`Cevap anahtarƒ± okuma: ${successCount}/${layoutConfig.questions.length} ba≈üarƒ±lƒ±`);
      
      return {
        success: successCount > 0,
        answers: answers,
        count: successCount
      };
    }

    // =====================================================
    // DOSYA Y√úKLEME FONKSƒ∞YONLARI
    // =====================================================
    
    let uploadedImage = null;
    
    function toggleScanSource() {
      const source = document.getElementById('scanSource').value;
      document.getElementById('cameraSection').style.display = source === 'camera' ? 'block' : 'none';
      document.getElementById('fileSection').style.display = source === 'file' ? 'block' : 'none';
      
      // Scan mode'u sƒ±fƒ±rla
      scanMode = 'student';
      document.getElementById('processFileBtn').textContent = 'üîç Formu Analiz Et';
      
      if (source === 'camera') {
        initCamera();
      } else {
        stopCamera();
        setLog('cameraLog', 'üìÅ Dosya y√ºkleme modu aktif. Resim se√ßin.', 'info');
      }
    }
    
    function handleFileSelect(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      if (!file.type.match('image.*')) {
        setLog('cameraLog', '‚ùå L√ºtfen bir resim dosyasƒ± se√ßin (PNG, JPG, JPEG)', 'error');
        return;
      }
      
      const reader = new FileReader();
      reader.onload = function(e) {
        const img = new Image();
        img.onload = function() {
          uploadedImage = img;
          
          // Resmi captureCanvas'a √ßiz
          const canvas = document.getElementById('captureCanvas');
          const ctx = canvas.getContext('2d');
          
          // Canvas boyutunu resme g√∂re ayarla (max 1280px geni≈ülik)
          const maxWidth = 1280;
          const scale = Math.min(1, maxWidth / img.width);
          canvas.width = Math.floor(img.width * scale);
          canvas.height = Math.floor(img.height * scale);
          
          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
          
          // Dosya adƒ±nƒ± g√∂ster
          document.getElementById('fileName').textContent = `‚úì ${file.name} (${Math.round(file.size/1024)} KB)`;
          document.getElementById('processFileBtn').disabled = false;
          document.getElementById('clearFileBtn').style.display = 'inline-flex';
          
          setLog('cameraLog', `‚úÖ Resim y√ºklendi: ${file.name}`, 'success');
          updateStatus('ready', 'Resim hazƒ±r');
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    }
    
    function processUploadedFile() {
      if (!uploadedImage || !cvReady) {
        setLog('cameraLog', '‚ö†Ô∏è √ñnce bir resim y√ºkleyin ve OpenCV hazƒ±r olsun.', 'error');
        return;
      }
      
      if (!layoutConfig || !layoutConfig.questions || layoutConfig.questions.length === 0) {
        setLog('cameraLog', '‚ö†Ô∏è √ñnce form tasarƒ±mƒ±nƒ± olu≈üturun (Tasarla sekmesi).', 'error');
        return;
      }
      
      setLog('cameraLog', 'üîç Resim analiz ediliyor...', 'info');
      updateStatus('scanning', 'Analiz ediliyor...');
      
      // captureCanvas'daki resmi i≈üle
      if (scanMode === 'answerKey') {
        processAnswerKeyFromFile();
        // Normal moda geri d√∂n
        scanMode = 'student';
        document.getElementById('processFileBtn').textContent = 'üîç Formu Analiz Et';
      } else {
        processStudentFormFromFile();
      }
    }
    
    function processStudentFormFromFile() {
      let src, gray, blurred, binary, markerOverlay;
      
      try {
        src = cv.imread('captureCanvas');
        if (src.empty()) {
          throw new Error('Resim okunamadƒ±');
        }
        
        gray = new cv.Mat();
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
        blurred = new cv.Mat();
        cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);
        binary = new cv.Mat();
        cv.adaptiveThreshold(blurred, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 11, 2);
        
        markerOverlay = src.clone();
        const markers = detectCornerMarkers(binary, markerOverlay);
        cv.imshow('markerCanvas', markerOverlay);
        
        if (!markers) {
          setLog('cameraLog', '‚ö†Ô∏è K√∂≈üe markerlarƒ± bulunamadƒ±. Formun k√∂≈üeleri g√∂r√ºn√ºr olmalƒ±.', 'error');
          updateStatus('error', 'Marker bulunamadƒ±');
          return;
        }
        
        const warped = warpPerspective(src, markers);
        cv.imshow('warpCanvas', warped);
        
        const result = analyzeBubbles(warped);
        renderResults(result);
        addSessionResult(result);
        
        updateStatus('found', '‚úì Form okundu!');
        setLog('cameraLog', '‚úÖ Analiz tamamlandƒ±!', 'success');
        
        warped.delete();
      } catch (e) {
        console.error(e);
        setLog('cameraLog', '‚ùå Hata: ' + e.message, 'error');
        updateStatus('error', 'Hata');
      } finally {
        if (src) src.delete();
        if (gray) gray.delete();
        if (blurred) blurred.delete();
        if (binary) binary.delete();
        if (markerOverlay) markerOverlay.delete();
      }
    }
    
    function processAnswerKeyFromFile() {
      let src, gray, blurred, binary, markerOverlay;
      
      try {
        src = cv.imread('captureCanvas');
        gray = new cv.Mat();
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
        blurred = new cv.Mat();
        cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);
        binary = new cv.Mat();
        cv.adaptiveThreshold(blurred, binary, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 11, 2);
        
        markerOverlay = src.clone();
        const markers = detectCornerMarkers(binary, markerOverlay);
        cv.imshow('markerCanvas', markerOverlay);
        
        if (!markers) {
          setLog('cameraLog', '‚ö†Ô∏è K√∂≈üe markerlarƒ± bulunamadƒ±', 'error');
          return;
        }
        
        const warped = warpPerspective(src, markers);
        cv.imshow('warpCanvas', warped);
        
        const result = readAnswerKeyFromScan(warped);
        
        if (result.success) {
          answerKey = result.answers;
          generateAnswerKeyGrid();
          updateAnswerKeyStatus();
          
          scanMode = 'student';
          document.getElementById('captureBtn').textContent = 'üì∏ √ñƒürenci Formu Tara';
          setLog('cameraLog', `‚úÖ Cevap anahtarƒ± y√ºklendi! ${Object.keys(answerKey).length} cevap okundu.`, 'success');
          updateStatus('ready', '‚úì Anahtar Y√ºklendi');
        } else {
          setLog('cameraLog', '‚ö†Ô∏è Cevap anahtarƒ± okunamadƒ±, tekrar deneyin', 'error');
        }
        
        warped.delete();
      } catch (e) {
        setLog('cameraLog', 'Hata: ' + e.message, 'error');
      } finally {
        if (src) src.delete();
        if (gray) gray.delete();
        if (blurred) blurred.delete();
        if (binary) binary.delete();
        if (markerOverlay) markerOverlay.delete();
      }
    }
    
    function clearUploadedFile() {
      uploadedImage = null;
      document.getElementById('fileInput').value = '';
      document.getElementById('fileName').textContent = '';
      document.getElementById('processFileBtn').disabled = true;
      document.getElementById('clearFileBtn').style.display = 'none';
      
      // Canvas'larƒ± temizle
      const canvases = ['captureCanvas', 'markerCanvas', 'warpCanvas'];
      canvases.forEach(id => {
        const canvas = document.getElementById(id);
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      });
      
      setLog('cameraLog', 'üóëÔ∏è Y√ºklenen resim temizlendi', 'info');
      updateStatus('ready', 'Hazƒ±r');
    }
  </script>
</body>
</html>
